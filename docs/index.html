<!DOCTYPE html>
<html lang="en">
<head>
<title>Interactive futures tutorial</title>
<style type="text/css" media="screen">
  div.editor { 
    width: 80em;
    height: 10em;
  }
  div.lesson {
    width: 82em;
    padding: 1em;
  }
  div.verify {
    display: none;
  }
  .passed {
    background-color: #ccffcc;
  }
  .failed {
    background-color: #ffcccc;
  }
  p {
    font-family: sans-serif;
  }
  .code > * {
    font-family: monospace;
  }
  td, th {
    text-align: left;
    padding-left: 0.5em; 
    padding-right: 0.5em;
    font-family: monospace;
  }
</style>
</head>
<body>

<h2>Intro</h2>
<p>
This is an interactive tutorial for futures. The code samples are intended to look and behave like Java but it's actually JavaScript.
"->" is automatically converted to "=>" so you can write lambdas like in Java.</p>

<p>Exceptions are similar to Java, but without anything fancy.</p>

<p>The <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CompletableFuture.html">CompletableFuture API</a> you can use here is a partial re-implementation in JavaScript. The functions you can use are listed below:
<p></p>
<p>Since Java 8:</p>
<ul class="code">
<li>var x = new CompletableFuture();
<li>var x = CompletableFuture.completedFuture(value);
<li> var newFuture = future.thenApply(value -> new_value);
<li> var newFuture = future.thenCompose(value -> new_future);
<li> var newFuture = future.exceptionally(exc -> new_value);
<li> var newFuture = future.handle((value, exc) -> new_value);
</ul>
<p>Since Java 9:</p>
<ul class="code">
<li>var x = CompletableFuture.failedFuture(exception);
</ul>
<p>Since Java 12:</p>
<ul class="code">
<li> var newFuture = future.exceptionallyCompose(exc -> new_future);
</ul>
</p>

<div id="lessons">
</div>
    
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js"></script>

<!-- https://cdnjs.com/libraries/ace -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js" type="text/javascript" charset="utf-8"></script>
<script>
  var basePath = "https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/";
  ace.config.set("basePath", basePath);
  ace.config.set("themePath", basePath);

  class Exception {
    constructor(message) {
      this._message = message;
    }
    
    static wrap(exc) {
      if (exc == null) {
        return new Exception("Nullpointer");
      } else if (exc instanceof Exception) {
        return exc;
      } else {
        return new Exception(exc);
      }
    }
    
    getMessage() {
      return this.toString();
    }
    
    toString() {
      return this._message;
    }
  }
  
  function _assert(expr, msg) {
    if (!expr) {
      throw new Exception("Assertion failed: " + msg);
    }
  }
  
  function _assert_exc(exc) {
    _assert(exc instanceof Exception, "Expected an exception but found " + exc);
  }
  
  function _assert_future(future) {
    _assert(future instanceof CompletableFuture, "Expected an future but found " + future);
  }
  
  function _assert_result(result) {
    _assert(result instanceof Result, "Expected a result but found " + result);
  }
  
  class Result {
    constructor(value, exception) {
      this._value = value;
      this._exception = exception;
    }
    
    static exception(exc) {
      return new Result(null, Exception.wrap(exc));
    }
    
    static value(value) {
      return new Result(value, null);
    }
    
    isException() {
      return this._exception != null;
    }

    isValue() {
      return this._exception == null;
    }
    
    equals(other) {
      return this._exception == other._exception && this._value == other._value;
    }
    
    toString() {
      if (this._exception != null) {
        return "Exception('" + this._exception.getMessage() + "')";
      }
      return "Value('" + this._value + "')";
    }
  }
  
  class CompletableFuture {
    constructor() {
      this._result = null;
      this._callbacks = [];
    }
    
    static completedFuture(value) {
      var newFuture = new CompletableFuture();
      newFuture.complete(value);
      return newFuture;
    }
    
    static failedFuture(exc) {
      _assert(_globalLanguageLevel >= 9, "Requires Java 9+");
      _assert_exc(exc);
      var newFuture = new CompletableFuture();
      newFuture.completeExceptionally(exc);
      return newFuture;
    }
    
    static _completed(result) {
      var f = new CompletableFuture();
      f._internalComplete(result);
      return f;
    }
    
    // fun: Exception => Future
    exceptionallyCompose(fun) {
      _assert(_globalLanguageLevel >= 12, "Requires Java 12+");
      return this
        .thenApply(x => CompletableFuture.completedFuture(x))
        .exceptionally(fun)
        .thenCompose(x => x);
    }
    
    // fun: (Value, Value) => Value
    thenCombine(other, fun) {
      return this.thenCompose(x => other.thenApply(y => fun(x, y)));
    }
    
    // fun: Exception => Value
    exceptionally(fun) {
      return this.handle((value, exc) => {
        if (exc != null) {
          return fun(exc);
        } else {
          return value;
        }
      });
    }

    // fun: Value => Value
    thenApply(fun) {
      return this.handle((value, exc) => {
        if (exc != null) {
          throw exc;
        } else {
          return fun(value);
        }
      });
    }
    
    // fun: Value => Future
    thenCompose(fun) {
      return this.thenApply(fun)._dereference();
    }
    
    // fun: (Value, Exception) => Value
    handle(fun) {
      return this._handle(result => {
        if (result.isValue()) {
          return Result.value(fun(result._value, null));
        } else {
          return Result.value(fun(null, result._exception));
        }
      });
    }
    
    // fun: Result => Result
    _handle(fun) {
      var newFuture = new CompletableFuture();
      this._addCallback(result => {
        try {
          var result2 = fun(result);
          _assert_result(result2);
          newFuture._internalComplete(result2);
        } catch (err) {
          newFuture._internalComplete(Result.exception(err));
        }
      });
      return newFuture;
    }
    
    _dereference() {
      var newFuture = new CompletableFuture();
      this._addCallback(result => {
        try {
          if (result.isValue()) {
            var future = result._value;
            _assert_future(future);
            future._addCallback(result2 => newFuture._internalComplete(result2))
          } else {
            newFuture._internalComplete(result);
          }
        } catch (err) {
          newFuture._internalComplete(Result.exception(err));
        }
      });
      return newFuture;
    }

    // fun: Result => Void
    // fun may not throw errors
    _addCallback(fun) {
      if (this.isComplete()) {
        fun(this._result);
      } else {
        this._callbacks.push(fun);
      }
    }
        
    isComplete() {
      return this._result != null;
    }
    
    getResult() {
      if (!this.isComplete()) {
        throw "Future is not completed";
      }
      return this._result;
    }
    
    getValue() {
      var res = getResult();
      if (res.isException()) {
        throw "Future completed exceptionally";
      }
      return res._value;
    }
    
    complete(value) {
      this._internalComplete(Result.value(value));
    }
    
    completeExceptionally(exc) {
      _assert_exc(exc);
      this._internalComplete(Result.exception(exc));
    }
    
    _internalComplete(result) {
      if (this._result == null) {
        this._result = result;
      }
      var callbacks = this._callbacks;
      this._callbacks = [];
      for (var callback of callbacks) {
        try {
          callback(result);
        } catch (err) {
          console.log("Unexpected error from callback: " + err.toString());
        }
      }
    }
    
    toString() {
      if (this._result != null) {
        return "CompleteFuture(" + this._result.toString() + ")";
      }
      return "IncompleteFuture";
    }
    
  }
  
  class ValueType {
    constructor(name) {
      this._name = name;
    }
    
    createReal() {
      return Result.value(this._name + ":" + Math.floor(Math.random() * 1000));
    }

    createExample() {
      return Result.value(this._name);
    }
  }

  class ExceptionType {
    constructor(name) {
      this._name = name;
    }
    
    createReal() {
      return Result.exception(this._name + ":" + Math.floor(Math.random() * 1000));
    }

    createExample() {
      return Result.exception(this._name);
    }
  }
  
  function compile(code, inputs) {
    var parameterList = inputs.join(', ');
    code = code.replaceAll("->", "=>");
    code = code.replaceAll("::", ".");
    code = "(" + parameterList + ") => { " + code + "}";
    return eval(code);
  }
  
  function evaluateFunction(code, inputs) {
    var inputFutures = [];
    for (var input of inputs) {
      inputFutures.push(new CompletableFuture());
    }
    var outputFuture = code(...inputFutures);

    // TODO: test various combinations of pre-completed inputs
    
    for (var inputFuture of inputFutures) {
      if (inputFuture.isComplete()) {
        throw "Unexpected modification of the input future";
      }
    }

    if (outputFuture == null) {
      throw "Output is null";
    }
    
    if (!(outputFuture instanceof CompletableFuture)) {
      throw "Return value has wrong type - expected CompletableFuture";
    }
    
    for (var i = 0; i < inputs.length; i++) {
      inputFutures[i]._internalComplete(inputs[i]);
    }
    
    if (!outputFuture.isComplete()) {
      throw "Output future did not complete";
    }
    
    return outputFuture.getResult();
  }
  
  function setupLesson(lesson) {
    var lessondiv = $('<div>', {class: 'lesson'});

    lessondiv.append($('<h3>').text(lesson.title))
    lessondiv.append($('<p>').text(lesson.text))
    
    try {
      var solution = compile(lesson.solution, lesson.inputs);
    } catch (err) {
      lessondiv.append($('<p>').text("Broken solution: " + solution + ", err: " + err));
    }
    
    var examples = $('<div>', {class: 'examples'});

    var testcases = [];
    var table = $('<table>');
    var tableheader = $('<tr>');
    tableheader.append($('<th>').text("Test"));
    for (var input of lesson.inputs) {
      tableheader.append($('<th>').text("Parameter " + input));
    }
    tableheader.append($('<th>').text("Output:"));

    var tablerows = $('<tbody>');
    var num = 0;
    for (var test of lesson.tests) {
      var parameters = [];
      var tr = $('<tr>');
      tr.append($('<td>').text(++num));
      for (var input of test) {
        var inputValue = input.createExample();
        parameters.push(CompletableFuture._completed(inputValue))
        tr.append($('<td>').text(inputValue.toString()));
      }
      try {
        var expected = solution(...parameters);
        tr.append($('<td>').text(expected.getResult().toString()));
      } catch (err) {
        tr.append($('<td>').text(err.toString()));
      }      
      tablerows.append(tr);
    }

    table
      .append($('<thead>').append(tableheader))
      .append(tablerows);
    
    examples.append(table);
    lessondiv.append(examples);
    
    var editordiv = $('<div>', {class: 'editor'});
    var editor = ace.edit(editordiv.get(0));
    editor.setTheme('ace/theme/monokai');
    editor.session.setMode('ace/mode/java');
    editor.setValue(lesson.code);
    
    var parameterList = lesson.inputs.join(', ');
    lessondiv.append(editordiv);

    var compilationdiv = $('<div>', {class: 'compilation'});
    var testcasesdiv = $('<div>', {class: 'testcases'});

    lessondiv.append(
      $('<button/>', {
          text: 'Run',
          click: () => {
            compilationdiv.empty();
            testcasesdiv.empty();
            try {
              var userFunction = compile(editor.getValue(), lesson.inputs);
            } catch (err) {
              compilationdiv.append($('<pre>').text("Compilation failed: " + err));
              return;
            }

            var tableheader = $('<tr>');
            tableheader.append($('<th>').text("Test"));
            for (var input of lesson.inputs) {
              tableheader.append($('<th>').text("Parameter " + input));
            }
            tableheader.append($('<th>').text("Actual:"));
            tableheader.append($('<th>').text("Expected:"));
            tableheader.append($('<th>').text("Error:"));

            var tablerows = $('<tbody>');
            var passed = true;
            var num = 0;
            for (var test of lesson.tests) {
              var tr = $('<tr>');
              tr.append($('<td>').text(++num));
              var inputValues = []
              for (var input of test) {
                var inputValue = input.createReal();
                inputValues.push(inputValue);
                tr.append($('<td>').text(inputValue.toString()));
              }
              try {
                _globalLanguageLevel = lesson.maxLanguageLevel;
                var actual = evaluateFunction(userFunction, inputValues);
                var expected = evaluateFunction(solution, inputValues);

                tr.append($('<td>').text(actual.toString()));
                tr.append($('<td>').text(expected.toString()));
                tr.append($('<td>').text(""));                 
                if (!actual.equals(expected)) {
                  passed = false;
                  tr.addClass("failed");
                } else {
                  tr.addClass("passed");
                }
              } catch (err) {
                tr.append($('<td>').text(""));                 
                tr.append($('<td>').text(""));                 
                tr.append($('<td>').text(err.toString()));
                passed = false;
                tr.addClass("failed");
              }
              tablerows.append(tr);
            }

            var table = $('<table>');
            table
              .append($('<thead>').append(tableheader))
              .append(tablerows);

            testcasesdiv.append(table);
           }
          }));
    lessondiv.append(compilationdiv);
    lessondiv.append(testcasesdiv);

    $("#lessons").append(lessondiv);
  }

  function setupLessons() {
    for (lesson of lessons) {
      setupLesson(lesson);
    }
  }

  var lessons = [
    {
      title: "Lesson 1",
      text: `Let's start by transforming a future into a new future.`,
      inputs: [
        "input"
      ],
      tests: [
        [new ValueType("input")],
        [new ExceptionType("input")],
      ],
      code: `return input.thenApply(v -> v);`,
      solution: `return input.thenApply(v -> v + "!");`,
      maxLanguageLevel: 12,
    },
    {
      title: "Lesson 2",
      text: `Now it's time to handle exceptions!
             Your code should do the same thing as before, but if the input future
             has an exception, your result future should convert the error string
             to "Error: " + exception`,
      inputs: [
        "input"
      ],
      tests: [
        [new ValueType("input")],
        [new ExceptionType("input")],
      ],
      code: `// Hint: use the exceptionally-method
return input.thenApply(v -> v);`,
      solution: `
return input
  .thenApply(v -> v + "!")
  .exceptionally(e -> "Error: " + e.getMessage());`,
      maxLanguageLevel: 12,
    },
    {
      title: "Lesson 3: Combining futures",
      text: `Now we are going to get two futures as input. Your job is to return a future that is the concatenation of the values.`,
      inputs: [
        "first", "second"
      ],
      tests: [
        [new ValueType("first"), new ValueType("second")],
        [new ValueType("first"), new ExceptionType("second")],
        [new ExceptionType("first"), new ExceptionType("second")],
      ],
      code: `// Hint: use thenCombine
return null`,
      solution: `
return first.thenCombine(second, (a,b)->a+b);`,
      maxLanguageLevel: 12,
    },
    {
      title: "Lesson 4: Combining many futures",
      text: `Now we are going to get four futures as input. Your job is to return a future that is the concatenation of the values.`,
      inputs: [
        "first", "second", "third", "fourth"
      ],
      tests: [
        [
          new ValueType("first"),
          new ValueType("second"),
          new ValueType("third"),
          new ValueType("fourth"),
        ],
      ],
      code: `// Hint: use thenCompose and thenApply
return null`,
      solution: `
return first.thenCompose(a -> second.thenCompose(b -> third.thenCompose(c -> fourth.thenApply(d -> a + b + c + d))));`,
      maxLanguageLevel: 12,
    },
    {
      title: "Lesson 5: Retry on exceptions",
      text: `Now we are going to simulate a retry on exception. To simplify things, the retry logic is represented by the future called retry.`,
      inputs: [
        "input", "retry"
      ],
      tests: [
        [new ValueType("input"), new ValueType("retry")],
        [new ValueType("input"), new ExceptionType("retry")],
        [new ExceptionType("input"), new ExceptionType("retry")],
        [new ExceptionType("input"), new ValueType("retry")],
      ],
      code: `// Hint: look in the Java 12 futures API
return null`,
      solution: `
return input.exceptionallyCompose(exc -> retry);`,
      maxLanguageLevel: 12,
    },
    {
      title: "Lesson 6: Retry on exceptions",
      text: `Same as the previous lesson, but now you are not allowed to use methods defined in Java 12+.`,
      inputs: [
        "input", "retry"
      ],
      tests: [
        [new ValueType("input"), new ValueType("retry")],
        [new ValueType("input"), new ExceptionType("retry")],
        [new ExceptionType("input"), new ExceptionType("retry")],
        [new ExceptionType("input"), new ValueType("retry")],
      ],
      code: `// Hint: Can you first transform value into a nested future and unwrap it in the end?
return null`,
      solution: `
return input.thenApply(v -> CompletableFuture.completedFuture(v))
  .exceptionally(exc -> retry)
  .thenCompose(f -> f);`,
      maxLanguageLevel: 11,
    },
  ];

  _globalLanguageLevel = 12;
  setupLessons();
</script>
</body>
</html>
